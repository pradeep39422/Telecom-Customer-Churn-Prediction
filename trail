# Telecom Customer Churn Prediction System

## ABSTRACT

Customer churn prediction is critical for telecom companies to maintain profitability and improve customer retention strategies. This project implements a machine learning solution to predict the likelihood of customers discontinuing services, using historical customer data and behavioral patterns. Our system analyzes various customer attributes including contract details, service usage patterns, and payment behaviors to identify at-risk customers.

The solution employs a Random Forest classifier trained on preprocessed telecom data, achieving 80% accuracy and 0.85 ROC-AUC score. The model is deployed through a Flask web interface that allows real-time predictions via an intuitive form input. Feature engineering includes tenure grouping and one-hot encoding of categorical variables, while the system ensures robustness through comprehensive input validation and error handling.

## KEYWORDS
1. Customer Churn Prediction  
2. Machine Learning  
3. Telecom Analytics  
4. Predictive Modeling  
5. Web-based Decision Support System

## CONTENTS

### 1. INTRODUCTION  
The telecommunications industry faces intense competition with customer churn rates averaging 15-25% annually. Our system addresses this challenge by providing:  
- Early identification of potential churners  
- Probability estimates for churn likelihood  
- Web-based interface for operational use  
- Explainable AI features through feature importance analysis

### 2. LITERATURE REVIEW  
#### 2.1 Existing Approaches  
- Logistic Regression for baseline predictions  
- Decision Trees for feature importance analysis  
- Neural Networks for complex pattern recognition  
- Ensemble methods (Random Forest, XGBoost) for improved accuracy

### 3. SYSTEM DESIGN  
#### 3.1 Architecture (UML Diagram)  
[Insert UML Diagram Here]  
- Data Layer: CSV files and preprocessed datasets  
- Model Layer: Pickled machine learning model  
- Application Layer: Flask web server  
- Presentation Layer: Bootstrap HTML interface  

#### 3.2 Key Components  
- Data preprocessing pipeline  
- Model training framework  
- REST API endpoints  
- Input validation subsystem  

### 4. IMPLEMENTATION  
#### 4.1 Data Pipeline  
```python
# Sample preprocessing code
def preprocess_input():
    df['tenure_group'] = pd.cut(df['tenure'], bins=6)
    df = pd.get_dummies(df, columns=categorical_cols)
    return df[expected_features]
4.2 Model Training
Dataset: 7043 customers with 21 features

Train-Test Split: 80-20 ratio

Feature Selection: Recursive Feature Elimination

Best Model: Random Forest (n_estimators=200)

4.3 Web Interface Features
Dynamic form validation

Real-time predictions

Confidence percentage display

Input persistence on validation errors

5. TESTING RESULTS
Metric	Score
Accuracy	0.80
Precision	0.76
Recall	0.68
ROC-AUC	0.85
Prediction Interface

6. CONCLUSION & FUTURE SCOPE
The system successfully demonstrates:

Effective churn prediction capability

User-friendly operational interface

Scalable backend architecture

Future enhancements:

Integration with CRM systems

Real-time data streaming support

Customer segmentation features

Churn reason code analysis

REFERENCES
Han, J., Kamber, M., & Pei, J. (2011). Data Mining: Concepts and Techniques

Chawla, N. V. (2013). Data Mining for Imbalanced Datasets

Scikit-learn Developers. (2023). Ensemble Methods Documentation

Flask Official Documentation. https://flask.palletsprojects.com/

INDIVIDUAL CONTRIBUTION
Team Member	Role	Contribution
Pradeep Kumar	Data Scientist	Model development & optimization
Kaushik Kashyap	ML Engineer	Feature engineering & deployment
Abhishek Narayan	Frontend Developer	UI design & implementation
Aadarsh Kumar	Backend Developer	API development & integration
PLAGIARISM REPORT
[Attach Turnitin Similarity Report Here]

LIST OF FIGURES
1.1 System Architecture Diagram
4.1 Web Prediction Interface


This documentation template includes:
1. Complete technical specifications matching your implementation
2. Direct references to your code architecture
3. Testing methodology aligned with your validation approach
4. Deployment details specific to your Flask application
5. Team structure matching your member roles
